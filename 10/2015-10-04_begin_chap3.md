第三章导语
==

在第一章与第二章已经介绍了如何把基本过程和基本数据组合起来，构造出复合的实体。在这其中，抽象起着至关重要的作用。

但是只是掌握了这些技巧，还不能够有效的设计大型系统，我们还需要一些组织规则，由它指导我们系统化地完成系统的整体设计。

这第三章将会介绍两种组织规则：一是基于对象，而是基于流处理。
- 基于对象我们平常最常用，它的基本方式就是对物理世界中的事物，抽象出一个与之相对应的对象。这样，在系统添加新对象时，可以尽量不影响其他对象。这些对象的行为可能随着时间的进展而不断变化。
- 基于流处理的组织策略，将注意力集中在流过系统的信息流上，这应该对应着函数式编程，因为在函数式编程里面，函数之间的调用是无副作用的，靠的就是函数的输入与输出来将整个程序串联起来。

## 面向对象的挑战

对于面向对象途径而言，我们必须关注计算对象可以怎样变化而同时又保留其标示。
这一点将抛弃在1.1.5小节中介绍的`替换模型`，而转向更机械式的`环境模型`。
在处理对象的变化与标示时，各种困难的基本根源在于我们需要在这一计算模型中与时间搏斗，如果允许程序并发执行，那么情况可能会更糟。

而流方式就没有这一问题，它能够通过`延时求值`的方式，松解在我们的模型中，对时间的模拟与计算机求值过程中的各种事件发生的顺序。

### 赋值与局部状态

每个计算对象都必须有它的一些局部状态变量，用于描述实际对象的状态。
由于被模拟系统里的对象状态是随着时间变化的，所以与之相对应的计算对象的状态也必须变化。
如果我们确定了要通过计算机里的时间顺序去模拟实际系统里的时间流逝，那么我们就必须构造起一些计算对象，使它们的行为随着程序的运行而改变。
特别是，如果需要用程序语言里的常规符号名字去模拟状态变量，那么语言就必须通过一个`赋值运算符`，使之能够去改变一个变量的值。

Scheme 里面提供的是`set!`
```
(set! <name> <new-value>)

; 例子
(define balance 100)
(define (withdraw amount)
  (if (>= balance amount)
    (begin
      (set! balance (- balance amount))
      balance)))
```

### 闭包

没错，这里又用到了闭包，不过和第二章的概念不一样，这里指的是常规编程语言中的闭包，也即：`在父函数调用结束后，内部函数保留父函数中的变量`