这道题目算是对这2.4小节的一个总结。下面我一一分析这三种方式的利与弊：

## 带有显示分派的通用型操作

很明显，这种方式无论是新增操作还是新增类型都是不好的，都需要修改所有的代码。

## 数据导向的通用型操作

这种情况就是把一种数据类型的所有操作封装到一个package中。
- 如果新增类型，只需再增加一个package即可，原有代码不需要修改，
- 如果新增操作，则需要修改每个package的实现

## 消息传递的通用型操作

这种情况就是把数据对象看作一个分发过程，根据实际传入的过程名来确定将要调用的过程。
- 如果新增类型，只需再增加一个分发过程，原有代码不需要修改
- 如果新增操作，则需要修改每个分发过程，把新增的操作添加上

## 总结

从上面的分析来看，显示分派的肯定是最不好的，应该不管新增类型还是新增操作都需要修改全局的代码

通用型操作（包括数据导向的方式与消息传递的方式两种）对于增加新类型来说，原有代码不需动，只需实现新类的package或分发过程即可。
增加新操作，这两种方式都需要改全局的代码。

但是数据导向的方式比消息传递的方式有一个好处，那就是

> 数据导向方式的操作可以有多个类型的参数（这也就是注解111所说的），而消息传递的只能有一个（因为它的参数只能有一个）。

注解111主要是说明了下面的情况：
```
(put 'real-part '(polar) real-part)
```
这里用的是列表polar，而不是polar符号，就是说可以出现下面的情况：
```
(put 'real-part '(polar rectangle) real-part-enhancement)
```
在我们的复数系统里应该不会出现这种情况，但是现实生活中的场景就很有可能了。